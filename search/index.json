[{"content":" 记录我们最珍贵的时刻，每一张都是爱的见证。\n","date":"2023-08-07T15:33:18+08:00","image":"https://xinhuizhineng.github.io/blog/images/photo-antique-style/1-1.jpg","permalink":"https://xinhuizhineng.github.io/blog/p/%E5%8F%A4%E9%A3%8E%E5%86%99%E7%9C%9F/","title":"古风写真"},{"content":"从输入 URL 到页面展示，这中间发生了什么？ 从输入 URL 到页面展示完整流程示意图： 浏览器进程：主要负责用户交互、子进程管理和文件储存等功能。 网络进程：面向渲染进程和浏览器进程等提供网络下载功能。 渲染进程：主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。 因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。 这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。 简要流程：\n首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。 然后，在网络进程中发起真正的 URL 请求。 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程。 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道。 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。 用户发出 URL 请求到页面开始解析的这个过程，就叫做 导航。\n详细阶段解析 1. 用户输入 当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是 搜索内容，还是 请求的 URL。\n如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://time.geekbang.org。 当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面。不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会。\nbeforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。\n当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。\n2. URL 请求过程 浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。\n首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。 这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。 接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。 服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。 在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。\n（1）重定向 在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。\n使用 curl -I + URL 的命令可以接收服务器返回的响应头的信息。\nHTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。\n（2）响应数据类型处理 Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型。\n案例 A：HTML 类型 执行命令：curl -I https://time.geekbang.org/\n响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是 HTML 格式。\n案例 B：下载类型 执行命令：curl -I https://res001.geekbang.org/.../geektime.apk\n从返回的响应头信息来看，其 Content-Type 的值是 application/octet-stream，显示数据是 字节流类型 的，通常情况下，浏览器会按照 下载类型 来处理该请求。\n如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。\n3. 准备渲染进程 那什么情况下多个页面会同时运行在一个渲染进程中呢？\n同一站点（same-site）：定义为 根域名（例如，geekbang.org）加上 协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口。\nChrome 的默认策略是，每个标签对应一个渲染进程。但 如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。\n总结来说，打开一个新页面采用的 渲染进程策略 就是：\n通常情况下，打开新的页面都会使用单独的渲染进程； 如果从 A 页面打开 B 页面，且 A 和 B 都属于 同一站点 的话，那么 B 页面复用 A 页面的渲染进程； 如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。 渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程。\n4. 提交文档 所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程。\n首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息； 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”； 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程； 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。 到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。\n5. 渲染阶段 一旦文档被提交，渲染进程便开始页面解析和子资源加载了。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。\n总结 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。\nChrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。\n浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。\n","date":"2023-01-30T13:05:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/","title":"导航流程"},{"content":"Step 1: 界面代码实现 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;btn\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;picture-img\u0026#34; ref=\u0026#34;uploadContent\u0026#34; id=\u0026#34;uploadContent\u0026#34; @click=\u0026#34;takePhotos()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loader-19\u0026#34; v-if=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;点击修改 \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; Step 2: 使用到的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 takePhotos() { const _that = this; if (document.getElementById(\u0026#34;take-picture\u0026#34;) == null) { let input = _that.createInputAndSetAttribute(); _that.$refs.uploadContent.$el.appendChild(input); input.onchange = async (event) =\u0026gt; { _that.loader = true; var files = event.target.files if (files \u0026amp;\u0026amp; files.length \u0026gt; 0) { const file = files[0]; // 压缩图片需要的一些元素和对象 var reader = new FileReader(), img = new Image(); // 缩放图片需要的canvas var canvas = document.createElement(\u0026#39;canvas\u0026#39;); var context = canvas.getContext(\u0026#39;2d\u0026#39;); // base64地址图片加载完毕后 img.onload = function() { // 图片原始尺寸 var originWidth = this.width; var originHeight = this.height; // 最大尺寸限制 var maxWidth = 960, maxHeight = 1280; // 目标尺寸 var targetWidth = originWidth, targetHeight = originHeight; // 图片尺寸超过400x400的限制 if (originWidth \u0026gt; maxWidth || originHeight \u0026gt; maxHeight) { if (originWidth / originHeight \u0026gt; maxWidth / maxHeight) { // 更宽，按照宽度限定尺寸 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); } else { targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); } } // canvas对图片进行缩放 canvas.width = targetWidth; canvas.height = targetHeight; // 清除画布 context.clearRect(0, 0, targetWidth, targetHeight); // 图片压缩 context.drawImage(img, 0, 0, targetWidth, targetHeight); // canvas转为blob并上传 canvas.toBlob(async (blob) =\u0026gt; { const newFile = new File([blob], \u0026#39;123.jpg\u0026#39;, { type: blob.type }) const imgPath = await upload(newFile, file.path, `/qy/photo`) const detectionRes = await detection(imgPath) await editFacePhoto(detectionRes).then(res =\u0026gt; { if (res.code === 0) { _that.photoSrc = res.imgUrl _that.$u.toast(\u0026#34;上传成功！\u0026#34;, 2000) } else { _that.$u.toast(res.msg, 3000) } }) _that.loader = false _that.removeDocument() }, file.type || \u0026#39;image/png\u0026#39;); }; // 文件base64化，以便获知图片原始尺寸 reader.onload = function(e) { img.src = e.target.result; }; reader.readAsDataURL(file); } } } document.querySelector(\u0026#34;#take-picture\u0026#34;).click(); } // 创建input并设置input的属性 createInputAndSetAttribute() { var input = document.createElement(\u0026#39;input\u0026#39;); input.type = \u0026#39;file\u0026#39;; input.id = \u0026#39;take-picture\u0026#39; input.accept = \u0026#39;image/*\u0026#39;; // input.capture = \u0026#39;user\u0026#39;; input.style.opacity = 0; input.style.position = \u0026#39;absolute\u0026#39;; input.style.top = 0; input.style.left = 0; input.style.width = \u0026#39;50px\u0026#39;; input.style.height = \u0026#39;50px\u0026#39;; return input; } // 移除input节点 removeDocument() { const uploadContent = document.getElementById(\u0026#34;uploadContent\u0026#34;); const takePicture = document.getElementById(\u0026#34;take-picture\u0026#34;); uploadContent.removeChild(takePicture); } 可参考： https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file\n","date":"2022-12-30T13:05:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/uniapp%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87h5/","title":"uniapp拍照上传图片h5"},{"content":" 参考: https://cloud.tencent.com/document/product/400/35244\n环境 1 2 ~$ nginx -v nginx version: nginx/1.18.0 (Ubuntu) 申请 SSL 证书 腾讯云\n下载 Nginx 服务器类型\n解压发送\n1 scp {chenjinxin.cn_bundle.crt,chenjinxin.cn.key} root@changxiangyu.cn:/usr/share/nginx/ 编辑服务器 Nginx 配置文件 /etc/nginx/nginx.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 user www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 768; # multi_accept on; } http { # changxiangyu.cn server { listen\t80; listen [::]:80; server_name changxiangyu.cn www.changxiangyu.cn; #把http的域名请求转成https return 301 https://$host$request_uri; #location / { #\troot /home/sammy/blog/public; #} #location /images { #\troot /home/sammy/data/; #\tautoindex on; #} } server { listen 443 ssl; ssl_certificate /usr/share/nginx/changxiangyu.cn_bundle.crt; ssl_certificate_key /usr/share/nginx/changxiangyu.cn.key; ssl_session_timeout 5m; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; server_name changxiangyu.cn www.changxiangyu.cn; location / { root /home/sammy/blog/public; } location /images { root /home/sammy/data/; autoindex on; } } # chenjinxin.cn server { listen\t80; listen [::]:80; server_name chenjinxin.cn www.chenjinxin.cn; #把http的域名请求转成https return 301 https://$host$request_uri; } server { listen 443 ssl; ssl_certificate /usr/share/nginx/chenjinxin.cn_bundle.crt; ssl_certificate_key /usr/share/nginx/chenjinxin.cn.key; ssl_session_timeout 5m; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; server_name chenjinxin.cn www.chenjinxin.cn; location / { root /home/sammy/cjx_blog/public; } location /images { root /home/sammy/data/; autoindex on; } } ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } #mail { #\t# See sample authentication script at: #\t# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # #\t# auth_http localhost/auth.php; #\t# pop3_capabilities \u0026#34;TOP\u0026#34; \u0026#34;USER\u0026#34;; #\t# imap_capabilities \u0026#34;IMAP4rev1\u0026#34; \u0026#34;UIDPLUS\u0026#34;; # #\tserver { #\tlisten localhost:110; #\tprotocol pop3; #\tproxy on; #\t} # #\tserver { #\tlisten localhost:143; #\tprotocol imap; #\tproxy on; #\t} #} 验证配置文件问题 1 sudo /usr/sbin/nginx -t 重载 Nginx 1 sudo /usr/sbin/nginx -s reload 成功后即可使用 chenjinxin.cn 进行访问\n","date":"2022-10-05T20:46:00+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D/","title":"单服务器绑定多个域名"},{"content":"更新源 1 sudo apt-get update 安装ssh服务 1 sudo apt-get install openssh-server 验证SSH服务 1 sudo systemctl status ssh 创建密钥 1 ssh-keygen ","date":"2022-09-13T14:44:00+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/ssh%E6%9C%8D%E5%8A%A1/","title":"ssh服务"},{"content":" 参考: https://www.jianshu.com/p/dc7e86b171cb\n安装软件工具 1 2 pip install requests pip install bypy 授权登陆 执行 bypy info，显示下边信息，根据提示，通过浏览器访问下边灰色的https链接，如果此时百度网盘账号正在登陆，会出现长串授权码，复制。\n1 2 3 4 5 6 [root@yu~]# bypy info Please visit: # 访问下边这个连接，复制授权码 https://openapi.baidu.com/oauth/2.0/authorize?scope=basic+netdisk\u0026amp;redirect_uri=oob\u0026amp;response_type=code\u0026amp;client_id=q8WE4EpCsau1oS0MplgMKNBn And authorize this app Paste the Authorization Code here within 10 minutes. Press [Enter] when you are done # 提示在下边粘贴授权码 在下边图示位置粘贴授权码，耐心等待一会即可\n1 2 3 4 5 Press [Enter] when you are done 2d2416c9e27c5b19f14da97c82daf18e Authorizing, please be patient, it may take upto 300 seconds... Quota: 14.020TB Used: 5.497TB 授权成功。\n测试上传和同步本地文件到云盘 由于百度PCS API权限限制，程序只能存取百度云端/apps/bypy目录下面的文件和目录。我们可以通过：\n1 2 [root@yu~]# bypy list /apps/bypy ($t $f $s $m $d): 把本地当前目录下的文件同步到百度云盘：\n1 bypy upload 把云盘上的内容同步到本地:\n1 bypy downdir 比较本地当前目录和云盘根目录，看是否一致，来判断是否同步成功：\n1 bypy compare ","date":"2022-09-07T14:18:00+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/","title":"Linux命令行上传文件到百度网盘"},{"content":"参考: https://blog.csdn.net/nklinsirui/article/details/104673286\nSSH远程执行脚本报错 SSH 远程执行脚本报错\u0026quot;command not found\u0026quot;。在宿主机可以执行命令。\n原因是之前将环境变量配置在了 /etc/profile 中，但是SSH远程执行脚本时实际上执行的是 non-login shell，而 non-login shell不会读取 /etc/profile 配置文件，只读取 ~/.bashrc。\nlogin shell和non-login shell 用SSH客户端登陆Linux系统时，要求输入用户名/密码登录或根据SSH key登录时，就是login shell。\n而在A机器上再用SSH免密码登录B机器，在B机器上执行Shell脚本，就是non-login shell。\n用Ansible在目标机器上远程执行Shell脚本时，也是non-login shell，因为Ansible是基于SSH的。\nlogin shell和non-login shell读取的环境变量配置文件 login-shell读取环境变量配置文件：\n/etc/profile ~/.bash_profile ~/.profile ~/.bashrc /etc/bashrc 注意：~/.bash_profile中已经引入了~/.bashrc，而~/.bashrc引入了/etc/bashrc，因此login shell可以读取到~/.bashrc和/etc/bashrc的配置。\n1 2 3 4 # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi non-login shell读取环境变量配置文件：\n/etc/bashrc ~/.bashrc 解决non-login shell的环境配置问题 方法一：\n将login-shell和non-login shell都需要的环境配置放在~/.bashrc中，其它配置放在~/.bash_profile中。\n方法二：\n如果环境配置只放在~/.bash_profile中，需要执行non-login shell时先source ~/.bash_profile再执行命令。\n方法三：\n在 ~/.bashrc 里添加: . /etc/profile。（立即生效需要: source ~/.bashrc）\n","date":"2022-09-06T11:33:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/ssh%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99command-not-found%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/","title":"SSH远程执行脚本报错command not found和环境变量问题"},{"content":"参考: https://www.cnblogs.com/pandabang/p/10441242.html\n音量大/小：上/下\n静音开/关：M\n回退/快进：ALT+左/右（步进10s），CTRL+左/右（步进1min）\n跳到指定时间：CTRL+T\n播放/暂停：空格\n停止播放：S（与暂停不同，按下停止后播放进度条回到视频最开始，且窗口不显示视频；而暂停时，窗口显示暂停时的视频）\n播放速度：{或- 减慢，最慢速度0.02倍正常速度；} 加速，最快速度31.25倍正常速度； = 正常速度\n全屏开/关：F\n纵横比切换：A（默认、16:9、4:3、1:1、16:10、2.21:1、2:35:1、2.39:1、5:4）\n窗口尺寸切换：Z（¼、½、原始尺寸、2倍原始尺寸）\n显示播放时间/总时长：T\n播放控件显示/不显示：CTRL+H\n","date":"2022-09-04T16:25:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/vlc%E6%92%AD%E6%94%BE%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"VLC播放器快捷键"},{"content":"参考：https://blog.csdn.net/wxhcyy/article/details/107718794\n下载安装文件 1 2 # 链接从官方找 wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz 解压 1 2 export d_path=\u0026#39;\u0026#39; tar xf Python-3.6.8.tar.xz -C $d_path 安装 1 2 3 4 cd $d_path ./configure --prefix=$d_path/python3.6.8 make all make install 测试 1 $d_path/python3.6.8/python -V ","date":"2022-08-26T16:27:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/linux-%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85-python/","title":"linux 系统，使用源码安装 Python"},{"content":"File -\u0026gt; Settings -\u0026gt; Project: project_name -\u0026gt; Project Interpreter -\u0026gt; Add\u0026hellip; -\u0026gt; Virtualenv Environment -\u0026gt; (配置) -\u0026gt; OK\nsource project_path/venv/bin/activate\n命令行 Installation\nTo install virtualenv via pip run:\n1 $ pip3 install virtualenv Usage\nCreation of virtualenv:\n1 $ virtualenv -p python3 \u0026lt;desired-path\u0026gt; Activate the virtualenv:\n1 $ source \u0026lt;desired-path\u0026gt;/bin/activate Deactivate the virtualenv:\n1 $ deactivate ","date":"2022-08-26T15:04:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/pycharm-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","title":"pycharm 项目配置虚拟环境"},{"content":"转载：https://juejin.cn/post/6844903602968854542\n设置记住密码（默认15分钟） 可以将你的密码缓存下来，只用输一次密码，以后都可以不用输入了。缺点就是密码都明文保存在 ~/.git-credential 文件中。\n1 git config --global credential.helper cache 如果想自己设置时间，可以使用以下命令：\n1 git config credential.helper \u0026#39;cache --timeout=3600\u0026#39; 这样就设置一个小时之后失效\n长期存储密码： 1 git config --global credential.helper store 增加远程地址的时候带上密码也是可以的。(推荐)\n1 http://yourname:password@git.oschina.net/name/project.git 补充：使用客户端也可以存储密码。\n如果你正在使用ssh而且想体验https带来的高速，那么你可以这样做： 切换到项目目录下 ：\n1 cd project/ 移除远程ssh方式的仓库地址\n1 git remote rm origin 复制代码增加https远程仓库地址\n1 git remote add origin http://yourname:password@git.oschina.net/name/project.git ","date":"2022-08-26T14:36:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/git-http%E6%96%B9%E5%BC%8F%E5%85%8D%E5%AF%86%E6%8F%90%E4%BA%A4/","title":"git http方式免密提交"},{"content":"参考链接\nhttps://www.ruanyifeng.com/blog/2020/08/rsync.html How To Use Rsync to Sync Local and Remote Directories on a VPS, Justin Ellingwood Mirror Your Web Site With rsync, Falko Timme Examples on how to use Rsync, Egidio Docile How to create incremental backups using rsync on Linux, Egidio Docile 一、简介 rsync 是一个常用的 Linux 应用程序，用于文件同步。\n它可以在本地计算机与远程计算机之间，或者两个本地目录之间同步文件（但不支持两台远程计算机之间的同步）。它也可以当作文件复制工具，替代cp和mv命令。\n它名称里面的r指的是 remote，rsync 其实就是\u0026quot;远程同步\u0026quot;（remote sync）的意思。与其他文件传输工具（如 FTP 或 scp）不同，rsync 的最大特点是会检查发送方和接收方已有的文件，仅传输有变动的部分（默认规则是文件大小或修改时间有变动）。\n二、安装 1 2 3 4 5 # Ubuntu/Debian $ sudo apt-get install rsync # CentOS/Red Hat $ sudo yum install rsync 注意，传输的双方都必须安装 rsync。\n三、基本用法 3.1 -r 参数 本机使用 rsync 命令时，可以作为cp和mv命令的替代方法，将源目录同步到目标目录。\n1 $ rsync -r source destination 上面命令中，-r表示递归，即包含子目录。注意，-r是必须的，否则 rsync 运行不会成功。source目录表示源目录，destination表示目标目录。\n如果有多个文件或目录需要同步，可以写成下面这样。\n1 $ rsync -r source1 source2 destination 上面命令中，source1、source2都会被同步到destination目录。\n3.2 -a 参数 -a参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以-a比-r更有用。下面的用法才是常见的写法。\n1 $ rsync -a source destination 目标目录destination如果不存在，rsync 会自动创建。执行上面的命令后，源目录source被完整地复制到了目标目录destination下面，即形成了destination/source的目录结构。\n如果只想同步源目录source里面的内容到目标目录destination，则需要在源目录后面加上斜杠。\n1 $ rsync -a source/ destination 上面命令执行后，source目录里面的内容，就都被复制到了destination目录里面，并不会在destination下面创建一个source子目录。\n3.3 -n 参数 如果不确定 rsync 执行后会产生什么结果，可以先用-n或\u0026ndash;dry-run参数模拟执行的结果。\n1 $ rsync -anv source/ destination 上面命令中，-n参数模拟命令执行的结果，并不真的执行命令。-v参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。\n3.4 \u0026ndash;delete 参数 默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用\u0026ndash;delete参数，这将删除只存在于目标目录、不存在于源目录的文件。\n1 $ rsync -av --delete source/ destination 上面命令中，\u0026ndash;delete参数会使得destination成为source的一个镜像。\n四、排除文件 4.1 \u0026ndash;exclude 参数 有时，我们希望同步时排除某些文件或目录，这时可以用\u0026ndash;exclude参数指定排除模式。\n1 2 3 $ rsync -av --exclude=\u0026#39;*.txt\u0026#39; source/ destination # 或者 $ rsync -av --exclude \u0026#39;*.txt\u0026#39; source/ destination 上面命令排除了所有 TXT 文件。\n注意，rsync 会同步以\u0026quot;点\u0026quot;开头的隐藏文件，如果要排除隐藏文件，可以这样写\u0026ndash;exclude=\u0026quot;.*\u0026quot;。\n如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。\n1 $ rsync -av --exclude \u0026#39;dir1/*\u0026#39; source/ destination 多个排除模式，可以用多个\u0026ndash;exclude参数。\n1 $ rsync -av --exclude \u0026#39;file1.txt\u0026#39; --exclude \u0026#39;dir1/*\u0026#39; source/ destination 多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个\u0026ndash;exclude参数。\n1 $ rsync -av --exclude={\u0026#39;file1.txt\u0026#39;,\u0026#39;dir1/*\u0026#39;} source/ destination 如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用\u0026ndash;exclude-from参数指定这个文件。\n1 $ rsync -av --exclude-from=\u0026#39;exclude-file.txt\u0026#39; source/ destination 4.2 \u0026ndash;include 参数 \u0026ndash;include参数用来指定必须同步的文件模式，往往与\u0026ndash;exclude结合使用。\n1 $ rsync -av --include=\u0026#34;*.txt\u0026#34; --exclude=\u0026#39;*\u0026#39; source/ destination 上面命令指定同步时，排除所有文件，但是会包括 TXT 文件。\n五、远程同步 5.1 SSH 协议 rsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器。\n1 $ rsync -av source/ username@remote_host:destination 也可以将远程内容同步到本地。\n1 $ rsync -av username@remote_host:source/ destination rsync 默认使用 SSH 进行远程登录和数据传输。\n由于早期 rsync 不使用 SSH 协议，需要用-e参数指定协议，后来才改的。所以，下面-e ssh可以省略。\n1 $ rsync -av -e ssh source/ user@remote_host:/destination 但是，如果 ssh 命令有附加的参数，则必须使用-e参数指定所要执行的 SSH 命令。\n1 $ rsync -av -e \u0026#39;ssh -p 2234\u0026#39; source/ user@remote_host:/destination 上面命令中，-e参数指定 SSH 使用2234端口。\n5.2 rsync 协议 除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用rsync://协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔::。\n1 $ rsync -av source/ 192.168.122.32::module/destination 注意，上面地址中的module并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。\n如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令。\n1 $ rsync rsync://192.168.122.32 rsync 协议除了使用双冒号，也可以直接用rsync://协议指定地址。\n1 $ rsync -av source/ rsync://192.168.122.32/module/destination 六、增量备份 rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。\n除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。\n具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。\n\u0026ndash;link-dest参数用来指定同步时的基准目录。\n1 $ rsync -a --delete --link-dest /compare/path /source/path /target/path 上面命令中，\u0026ndash;link-dest参数指定基准目录/compare/path，然后源目录/source/path跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录/target/path。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了。\n下面是一个脚本示例，备份用户的主目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/bin/bash # A script to perform incremental backups using rsync set -o errexit set -o nounset set -o pipefail readonly SOURCE_DIR=\u0026#34;${HOME}\u0026#34; readonly BACKUP_DIR=\u0026#34;/mnt/data/backups\u0026#34; readonly DATETIME=\u0026#34;$(date \u0026#39;+%Y-%m-%d_%H:%M:%S\u0026#39;)\u0026#34; readonly BACKUP_PATH=\u0026#34;${BACKUP_DIR}/${DATETIME}\u0026#34; readonly LATEST_LINK=\u0026#34;${BACKUP_DIR}/latest\u0026#34; mkdir -p \u0026#34;${BACKUP_DIR}\u0026#34; rsync -av --delete \\ \u0026#34;${SOURCE_DIR}/\u0026#34; \\ --link-dest \u0026#34;${LATEST_LINK}\u0026#34; \\ --exclude=\u0026#34;.cache\u0026#34; \\ \u0026#34;${BACKUP_PATH}\u0026#34; rm -rf \u0026#34;${LATEST_LINK}\u0026#34; ln -s \u0026#34;${BACKUP_PATH}\u0026#34; \u0026#34;${LATEST_LINK}\u0026#34; 上面脚本中，每一次同步都会生成一个新目录${BACKUP_DIR}/${DATETIME}，并将软链接${BACKUP_DIR}/latest指向这个目录。下一次备份时，就将${BACKUP_DIR}/latest作为基准目录，生成新的备份目录。最后，再将软链接${BACKUP_DIR}/latest指向新的备份目录。\n七、配置项 -a、\u0026ndash;archive参数表示存档模式，保存所有的元数据，比如修改时间（modification time）、权限、所有者等，并且软链接也会同步过去。\n\u0026ndash;append参数指定文件接着上次中断的地方，继续传输。\n\u0026ndash;append-verify参数跟\u0026ndash;append参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。\n-b、\u0026ndash;backup参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由\u0026ndash;suffix参数指定的文件后缀名，默认是~。\n\u0026ndash;backup-dir参数指定文件备份时存放的目录，比如\u0026ndash;backup-dir=/path/to/backups。\n\u0026ndash;bwlimit参数指定带宽限制，默认单位是 KB/s，比如\u0026ndash;bwlimit=100。\n-c、\u0026ndash;checksum参数改变rsync的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。\n\u0026ndash;delete参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。\n-e参数指定使用 SSH 协议传输数据。\n\u0026ndash;exclude参数指定排除不进行同步的文件，比如\u0026ndash;exclude=\u0026quot;*.iso\u0026quot;。\n\u0026ndash;exclude-from参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。\n\u0026ndash;existing、\u0026ndash;ignore-non-existing参数表示不同步目标目录中不存在的文件和目录。\n-h参数表示以人类可读的格式输出。\n-h、\u0026ndash;help参数返回帮助信息。\n-i参数表示输出源目录与目标目录之间文件差异的详细情况。\n\u0026ndash;ignore-existing参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。\n\u0026ndash;include参数指定同步时要包括的文件，一般与\u0026ndash;exclude结合使用。\n\u0026ndash;link-dest参数指定增量备份的基准目录。\n-m参数指定不同步空目录。\n\u0026ndash;max-size参数设置传输的最大文件的大小限制，比如不超过200KB（\u0026ndash;max-size=\u0026lsquo;200k\u0026rsquo;）。\n\u0026ndash;min-size参数设置传输的最小文件的大小限制，比如不小于10KB（\u0026ndash;min-size=10k）。\n-n参数或\u0026ndash;dry-run参数模拟将要执行的操作，而并不真的执行。配合-v参数使用，可以看到哪些内容会被同步过去。\n-P参数是\u0026ndash;progress和\u0026ndash;partial这两个参数的结合。\n\u0026ndash;partial参数允许恢复中断的传输。不使用该参数时，rsync会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与\u0026ndash;append或\u0026ndash;append-verify配合使用。\n\u0026ndash;partial-dir参数指定将传输到一半的文件保存到一个临时目录，比如\u0026ndash;partial-dir=.rsync-partial。一般需要与\u0026ndash;append或\u0026ndash;append-verify配合使用。\n\u0026ndash;progress参数表示显示进展。\n-r参数表示递归，即包含子目录。\n\u0026ndash;remove-source-files参数表示传输成功后，删除发送方的文件。\n\u0026ndash;size-only参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。\n\u0026ndash;suffix参数指定文件名备份时，对文件名添加的后缀，默认是~。\n-u、\u0026ndash;update参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。\n-v参数表示输出细节。-vv表示输出更详细的信息，-vvv表示输出最详细的信息。\n\u0026ndash;version参数返回 rsync 的版本。\n-z参数指定同步时压缩数据。\n","date":"2022-08-19T17:03:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/%E8%BF%9C%E7%A8%8B%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-rsync/","title":"远程传输文件-rsync"},{"content":" 1 find . -type f -name \u0026#34;*.yaml\u0026#34; | xargs sed -i \u0026#34;s#host_path#$host_path#g\u0026#34; ","date":"2022-08-17T17:38:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"替换文件夹中所有文件内容的特定字符串"},{"content":"参考: https://blog.csdn.net/laobai1015/article/details/98628860\n需求 把 /etc/rancher/k3s/k3s.yaml 文件的内容，每行前面加 4 个空格，追加到 ai-service-platform/yamls/config/kube-config.yaml 文件中； 把 ai-service-platform/yamls/config/kube-config.yaml 文件中的 127.0.0.1 替换成 $master_host_ip。 脚本：\n1 2 3 4 function fix_kube_config(){ sudo awk \u0026#39;{print \u0026#34; \u0026#34; $0 \u0026gt;\u0026gt; \u0026#34;ai-service-platform/yamls/config/kube-config.yaml\u0026#34;}\u0026#39; /etc/rancher/k3s/k3s.yaml sed -i \u0026#34;s/127.0.0.1/$master_host_ip/g\u0026#34; ai-service-platform/yamls/config/kube-config.yaml } 扩展 在前面、后面、指定列添加相同字符\n给一个文件中的每一行开头插入字符的方法：awk \u0026lsquo;{print \u0026ldquo;需要添加的字符\u0026rdquo; $0}\u0026rsquo; fileName 给一个文件中的每一行结尾插入字符的方法：awk \u0026lsquo;{print $0 \u0026ldquo;需要添加的字符\u0026rdquo;}\u0026rsquo; fileName 给一个文件中的每一行的指定列插入字符的方法：awk \u0026lsquo;$0=$0 X\u0026quot;\u0026rsquo; fileName 删除某一个列\n删除文件中的第一列：awk \u0026lsquo;{$1=\u0026quot;\u0026quot;;print $0}\u0026rsquo; fileName 或者另一种方法 sed -e \u0026rsquo;s/[^ ]* //\u0026rsquo; text 删除指定列：awk \u0026lsquo;{$Num=\u0026quot;\u0026quot;;print $0}\u0026rsquo; fileName 把Num换成要删除的列数即可\n练习 给文件中的每一行开头添加drop tables\n1 awk \u0026#39;{print \u0026#34;drop table \u0026#34;$0}\u0026#39; aa.txt \u0026gt; bb.txt 给文件中的每一行结尾添加分号\n1 awk \u0026#39;{print $0\u0026#34;;\u0026#34;}\u0026#39; bb.txt \u0026gt; cc.txt ","date":"2022-08-17T10:03:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/linux-%E4%B8%8B%E4%BD%BF%E7%94%A8-awk-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/","title":"Linux 下使用 awk 操作文件内容"},{"content":"参考: https://developer.aliyun.com/article/53579\nmycode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import os import math if __name__ == \u0026#39;__main__\u0026#39;: vfs = os.statvfs(\u0026#34;/home/manager\u0026#34;) g = 1024 * 1024 * 1024 # 总容量 k_blocks = vfs.f_bsize * vfs.f_blocks / g # Used,使用量，总容量减去空闲容量 used = vfs.f_bsize * (vfs.f_blocks - vfs.f_bfree) / g # Available，有效容量 available = vfs.f_bsize * vfs.f_bavail / g # use%,使用量，%,round(浮点数，精确到小数点后的位数） use = round(used / (used + available) * 100, 2) print({ \u0026#34;容量\u0026#34;: k_blocks, \u0026#34;已用\u0026#34;: used, \u0026#34;可用\u0026#34;: available, \u0026#34;已用%\u0026#34;: use, }) print({ \u0026#34;容量\u0026#34;: f\u0026#39;{math.ceil(k_blocks)}G\u0026#39;, \u0026#34;已用\u0026#34;: f\u0026#39;{math.ceil(used)}G\u0026#39;, \u0026#34;可用\u0026#34;: f\u0026#39;{math.ceil(available)}G\u0026#39;, \u0026#34;已用%\u0026#34;: f\u0026#39;{math.ceil(use)}%\u0026#39;, }) 运行测试\n1 2 3 $ df -h /home/manager 文件系统 容量 已用 可用 已用% 挂载点 /dev/nvme0n1p2 457G 325G 110G 75% / 1 2 3 python test.py {\u0026#39;容量\u0026#39;: 456.8854446411133, \u0026#39;已用\u0026#39;: 324.40053939819336, \u0026#39;可用\u0026#39;: 109.20629501342773, \u0026#39;已用%\u0026#39;: 74.81} {\u0026#39;容量\u0026#39;: \u0026#39;457G\u0026#39;, \u0026#39;已用\u0026#39;: \u0026#39;325G\u0026#39;, \u0026#39;可用\u0026#39;: \u0026#39;110G\u0026#39;, \u0026#39;已用%\u0026#39;: \u0026#39;75%\u0026#39;} ","date":"2022-08-15T17:03:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/python-%E5%AE%9E%E7%8E%B0-linux-%E7%9A%84-df-h-%E5%91%BD%E4%BB%A4/","title":"Python 实现 Linux 的 'df -h' 命令"},{"content":"编辑文件：\n1 sudo gedit /etc/systemd/logind.conf 1 2 3 4 #HandlePowerKey按下电源键后的行为，默认power off #HandleSleepKey 按下挂起键后的行为，默认suspend #HandleHibernateKey按下休眠键后的行为，默认hibernate #HandleLidSwitch合上笔记本盖后的行为，一般为默认suspend（改为ignore；即合盖不休眠）在原文件中，还要去掉前面的# 1 2 3 4 然后将其中的： #HandleLidSwitch=suspend 复制一行到下面，去掉“#”号： HandleLidSwitch=ignore 最后重启服务\n1 service systemd-logind restart ","date":"2022-08-13T15:33:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/ubuntu-%E8%AE%BE%E7%BD%AE%E5%90%88%E4%B8%8A%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9B%96%E5%AD%90%E4%B8%8D%E4%BC%91%E7%9C%A0%E7%9A%84%E6%96%B9%E6%B3%95/","title":"Ubuntu 设置合上笔记本盖子不休眠的方法"},{"content":"pip freeze \u0026gt; test.txt\npip uninstall -r test.txt -y\npip install -r requirements.txt\n","date":"2022-08-08T18:13:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/python-%E6%B8%85%E7%90%86%E5%8C%85/","title":"python 清理包"},{"content":"准备检查：内存条，硬盘，主板电池\n","date":"2022-08-08T18:13:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/%E7%94%B5%E8%84%91%E5%BC%80%E4%B8%8D%E4%BA%86%E6%9C%BA/","title":"电脑开不了机"},{"content":" 记录我们最珍贵的时刻，每一张都是爱的见证。\n","date":"2022-08-07T15:47:18+08:00","image":"https://xinhuizhineng.github.io/blog/images/small-15x15-album/fm-15.jpg","permalink":"https://xinhuizhineng.github.io/blog/p/%E5%A9%9A%E7%BA%B1%E7%85%A7-15x15-%E7%9B%B8%E5%86%8C%E7%B2%BE%E9%80%89/","title":"婚纱照 15x15 相册精选"},{"content":" 记录我们最珍贵的时刻，每一张都是爱的见证。\n","date":"2022-08-07T15:33:18+08:00","image":"https://xinhuizhineng.github.io/blog/images/small-12x12-album/fm-15.jpg","permalink":"https://xinhuizhineng.github.io/blog/p/%E5%A9%9A%E7%BA%B1%E7%85%A7-12x12-%E7%9B%B8%E5%86%8C/","title":"婚纱照 12x12 相册"},{"content":"初见三摆台 至美三件套艺术组合 10X8英寸时尚绢丝相架一幅 10X8英寸精美思慕相架一幅 30X20英寸时尚绢丝挂画一幅 48X24至美相框一幅 6X8英寸时尚蓝色恋人相架一幅 8X12英寸精美米娜相架一幅 8X8英寸安琪相架一幅 ","date":"2022-08-07T15:33:18+08:00","image":"https://xinhuizhineng.github.io/blog/images/small-photos-decorations/y_259.jpg","permalink":"https://xinhuizhineng.github.io/blog/p/%E5%A9%9A%E7%BA%B1%E7%85%A7%E6%91%86%E4%BB%B6/","title":"婚纱照摆件"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 # 准备工作：安装 imagemagick sudo apt-get install imagemagick #大图所在的目录 cd /path/to/big/images #创建小图对应的目录结构 find . -type d -print -exec mkdir \u0026#39;../small/{}\u0026#39; -p \\; #批量转换! 等比例缩小到320x320之内 320x: 只设置宽度 find . -type f -name \u0026#39;*.jpg\u0026#39; -print -exec \\ convert \u0026#39;{}\u0026#39; -resize 320x320 \u0026#39;../small/{}\u0026#39; \\; ","date":"2022-08-07T02:33:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/ubuntu%E4%B8%8B%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E7%BC%A9%E7%95%A5%E5%9B%BE/","title":"Ubuntu下在命令行批量生成缩略图"},{"content":"Step 1: Install Hugo 1 2 3 # Ubuntu 系统 sudo apt update sudo apt install hugo 验证您的新安装:\n1 hugo version 1 2 Output hugo v0.101.0-9f74196ce611cdf6d355bfb99fd8eba5c68ef7f8+extended linux/amd64 BuildDate=2022-06-28T10:02:18Z VendorInfo=snap Step 2: Create a New Site 1 hugo new site quickstart 这个命令会创建一个名为 quickstart 的目录，这就是博客的根目录。目录结构如下：\n1 2 3 4 5 6 7 8 ├── archetypes │ └── default.md ├── config.toml # 博客站点的配置文件 ├── content # 博客文章所在目录 ├── data ├── layouts # 网站布局 ├── static # 一些静态内容 └── themes # 博客主题 Step 3: Add a Theme 首先，从 GitHub 下载主题并将其添加到站点的主题目录中：\n1 2 3 cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中：\n1 echo theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml Step 4: Add Some Content 1 hugo new posts/my-first-post.md 如果需要，可以编辑新创建的内容文件，它将以如下内容开头：\n1 2 3 4 5 --- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- Step 5: Start the Hugo server 现在，启动启用草稿的 Hugo 服务器：\n1 2 3 4 5 6 hugo server -D # 可以在其它机器访问 hugo server --bind=\u0026#34;0.0.0.0\u0026#34; -D # 可以在其它机器访问, -p 修改端口 hugo server --bind=\u0026#34;0.0.0.0\u0026#34; -p 80 -D 在 http://114.132.247.115:1313/ 导航到您的新站点。\n第 6 步：自定义主题 在文本编辑器中打开 config.toml：\n1 2 3 4 baseURL = \u0026#34;https://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;ananke\u0026#34; 第 7 步：构建静态页面 1 hugo -D ","date":"2022-08-01T19:52:18+08:00","permalink":"https://xinhuizhineng.github.io/blog/p/quick-start/","title":"Quick Start"},{"content":"准备要部署的内容 在github 上创建一个仓库: chenjinxin.github.io\n要向仓库中存放的内容，使用 hugo 命令生成的。在当前目录下，运行 hugo 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ➜ quickstart git:(master) ✗ pwd /home/cjx/quickstart ➜ quickstart git:(master) hugo Start building sites … hugo v0.101.0-9f74196ce611cdf6d355bfb99fd8eba5c68ef7f8+extended linux/amd64 BuildDate=2022-06-28T10:02:18Z VendorInfo=snap | EN -------------------+----- Pages | 28 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 12 Sitemaps | 1 Cleaned | 0 Total in 33 ms 执行成功后，会生成一个public 目录，这个目录中的内容，就是我们博客系统的所有内容，我们需要将这些内容存放在Git 仓库中。\n部署到 GitHub 按照如下步骤将博客内容上传到Git 仓库，在public 目录下，依次执行下面的命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 初始化仓库 git init # 将所有内容添加到git git add . # 提交到git 本地 git commit -m \u0026#34;我的博客第一次提交\u0026#34; # 关联到远程git，注意这里需要写你自己的git 地址 git remote add origin git@github.com:chenjinxin1124/chenjinxin.github.io.git # 推送到远程git git push --set-upstream origin master ","date":"2022-08-01T00:00:00Z","permalink":"https://xinhuizhineng.github.io/blog/p/%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%9C%A8github%E4%B8%8A/","title":"将博客部署在GitHub上"},{"content":"初始化本地仓库 1 git init 添加代码 1 git add . 提交代码 1 git commit -m\u0026#39;first commit\u0026#39; 添加远程仓库地址 1 git remote add origin git@github.com:jinyumantangcjx/hugo.git 把本地仓库的变化连接到远程仓库主分支 1 git push --set-upstream origin master ","date":"2022-08-01T00:00:00Z","permalink":"https://xinhuizhineng.github.io/blog/p/%E6%8E%A8%E9%80%81%E5%88%B0github/","title":"推送到GitHub"},{"content":"下载博客主题 创建好博客项目后，接下来是下载hugo博客的主题，这里有很多主题，我们可以任意挑选，比如我们选择了bootstrap4-blog 主题。\n然后在 Blog 目录下使用git 命令来下载主题：\n1 git clone https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/hugo-theme-bootstrap4-blog 下载下来的主题会放在themes 目录中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 └── hugo-theme-bootstrap4-blog ├── CHANGELOG.md ├── LICENSE.txt ├── README.md ├── archetypes ├── assets ├── exampleSite # 本主题示例内容 | ├── content # 示例博客文章 │ |-- static │ |-- config.toml # 本主题配置 ├── i18n ├── images ├── layouts ├── package-lock.json ├── package.json ├── screenshot.png ├── source ├── theme.toml └── webpack.config.js 使用主题 1 2 3 vim config.toml theme = \u0026#34;hugo-theme-bootstrap4-blog\u0026#34; ","date":"2022-08-01T00:00:00Z","permalink":"https://xinhuizhineng.github.io/blog/p/%E4%BF%AE%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/","title":"修改博客主题"}]